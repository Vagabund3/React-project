{"version":3,"sources":["components/Profile/ProfileInfo/ProfileInfo.module.css","components/Profile/MyPosts/MyPosts.module.css","components/Profile/MyPosts/Post/Post.module.css","components/Profile/ProfileInfo/ProfileStatus.jsx","components/Profile/ProfileInfo/ProfileStatusWithHooks.jsx","components/Profile/ProfileInfo/ProfileInfo.jsx","components/Profile/MyPosts/Post/Post.jsx","components/Profile/MyPosts/MyPosts.jsx","components/Profile/MyPosts/MyPostsContainer.jsx","components/Profile/Profile.jsx","components/Profile/ProfileContainer.jsx"],"names":["module","exports","React","Component","ProfileStatusWithHooks","props","useState","editMode","setEditMode","status","setStatus","useEffect","onDoubleClick","onChange","e","currentTarget","value","autoFocus","onBlur","updateStatus","ProfileInfo","profile","className","s","descriptionBlock","src","photos","large","Preloader","Post","item","message","likesCount","maxLength10","maxLengthCreator","AddNewPostFormRedux","reduxForm","form","onSubmit","handleSubmit","Field","name","component","Textarea","placeholder","validate","required","MyPosts","memo","postsElements","posts","map","p","createRef","postsBlock","values","addPost","newPostText","connect","state","profilePage","dispatch","addPostCreator","Profile","MyPostsContainer","ProfileContainer","userId","this","match","params","authorizedUserId","history","push","getUsersProfile","getStatus","compose","auth","isAuth","withRouter"],"mappings":"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","file":"static/js/3.e96e43d0.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"descriptionBlock\":\"ProfileInfo_descriptionBlock__u8UeR\",\"imgTrash\":\"ProfileInfo_imgTrash__6t6bT\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"postsBlock\":\"MyPosts_postsBlock__2ibmb\",\"posts\":\"MyPosts_posts__3FjRZ\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"item\":\"Post_item__dU6vr\"};","import React from \"react\";\r\nimport s from \"./ProfileInfo.module.css\";\r\nimport Preloader from \"../../common/Preloader/Preloader\";\r\n\r\nclass ProfileStatus extends React.Component {\r\n  state = {\r\n    editMode: false,\r\n    status: this.props.status,\r\n  };\r\n\r\n  //метод для обработки onDoubleClick\r\n  activateEditMode = () => {\r\n    this.setState({\r\n      editMode: true,\r\n    });\r\n  };\r\n\r\n  deactivateEditMode = () => {\r\n    this.setState({\r\n      editMode: false,\r\n    });\r\n    this.props.updateStatus(this.state.status); //передаем статус.\r\n  };\r\n\r\n  //благодаря (е) узнаем новое значение currentTarget.value и это новое знач. засетаем в качестве статуса local state. На каждое нажатие будет меняться local state, а input зависит от него\r\n  onStatusChange = (e) => {\r\n    this.setState({ status: e.currentTarget.value });\r\n  };\r\n\r\n  //cm. тетрадь на 18 стр.\r\n  componentDidUpdate(prevProps, prevState) {\r\n    if (prevProps.status != this.props.status) {\r\n      this.setState({\r\n        status: this.props.status,\r\n      });\r\n    }\r\n  }\r\n\r\n  render() {\r\n    console.log(\"render\");\r\n    return (\r\n      <div>\r\n        {!this.state.editMode && ( //если не editMode(!) то отобразим span\r\n          <div>\r\n            <span //показывает глобальный state\r\n              onDoubleClick={this.activateEditMode}\r\n            >\r\n              {this.props.status || \"-----\"} {/* если статуса нет то --- */}\r\n              {/*здесь показываем props потому-что еще не обновился сервак,ушли из editMode,отправили запрос на сервак,он еще думает,а пользователь видит пока старый статус,но потом появл новый,тк в  bll обновился status заново через пропсы пришел акуальный и мы его увидели  */}\r\n            </span>\r\n          </div>\r\n        )}\r\n        {this.state.editMode && ( // если editMode то тогда input\r\n          <div>\r\n            <input //показывает local state\r\n              onChange={this.onStatusChange}\r\n              autoFocus={true} //input когда активируется,он заберет фокус на себя\r\n              onBlur={this.deactivateEditMode} //onBlur фокус в эллементе\r\n              value={this.state.status} //показываем из local state статус\r\n            />\r\n          </div>\r\n        )}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ProfileStatus;\r\n","import React, { useEffect, useState } from \"react\";\r\nimport s from \"./ProfileInfo.module.css\";\r\nimport Preloader from \"../../common/Preloader/Preloader\";\r\n\r\n//функциональ компонента должна ообразить статус пришедший из props\r\n\r\nconst ProfileStatusWithHooks = (props) => {\r\n  // let arr = [0,() => {}]; пример того что мы делаем ниже - Деструктурирующее присваивание\r\n  // let [a, setA] = arr\r\n  //значение по умолчанию false\r\n\r\n  let [editMode, setEditMode] = useState(false); //useState возвращ значение(editMode) и функцию к которой можем это значение менять-setEditMode. и useState возвращ. массив и из него достаем первый элемент editMode и второй элемент setEditMode и записываем их в переменную\r\n  let [status, setStatus] = useState(props.status); //localState\r\n\r\n  //hook который говорит закинте в меня функцию которую я выполню кoгда произойдет отрисовка //когда компонента отрисовалась мы можем засинхронизировать setStatus который хранится в state c помощью useState, засинхронить теми данными которые пришли из props\r\n  //здесь нужно сказать ReactУ,что useEffect наш запускай не всегда,а только 1 раз, в момент когда происходит отрисовка\r\n  //хотим  чтобы useEffect запускался когда будет изменен props.status,коворим ReactУ что зависим от props.status\r\n  //Если props.status при очередной отрисовки будет не таким каким он был раньше то запускается useEffect\r\n  useEffect(() => {\r\n    setStatus(props.status);\r\n  }, [props.status]);\r\n\r\n  //сетаем локальный state\r\n  const activateEditMode = () => {\r\n    setEditMode(true);\r\n  };\r\n\r\n  const deactivateEditMode = () => {\r\n    setEditMode(false);\r\n    props.updateStatus(status); //передаем статус.\r\n  };\r\n\r\n  //при каждом напечатывании символа изменяем localState с помощью setStatus\r\n  //благодаря (е) узнаем новое значение currentTarget.value и это новое знач. засетаем в качестве статуса local state. На каждое нажатие будет меняться local state, а input зависит от него\r\n  const onStatusChange = (e) => {\r\n    setStatus(e.currentTarget.value);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      {!editMode && ( //если не editMode то показ span\r\n        <div>\r\n          <span onDoubleClick={activateEditMode}>\r\n            {props.status || \"-----\"} {/* если статуса нет то --- */}\r\n            {/*здесь показываем props потому-что еще не обновился сервак,ушли из editMode,отправили запрос на сервак,он еще думает,а пользователь видит пока старый статус,но потом появл новый,тк в  bll обновился status заново через пропсы пришел акуальный и мы его увидели  */}\r\n          </span>\r\n        </div>\r\n      )}\r\n\r\n      {editMode && (\r\n        <div>\r\n          <input\r\n            //показывает local state\r\n            onChange={onStatusChange}\r\n            autoFocus={true}\r\n            onBlur={deactivateEditMode} //onBlur фокус в эллементе\r\n            value={status} //показываем из local state статус\r\n          />\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ProfileStatusWithHooks;\r\n","import React from \"react\";\r\nimport s from \"./ProfileInfo.module.css\";\r\nimport Preloader from \"../../common/Preloader/Preloader\";\r\nimport ProfileStatus from \"./ProfileStatus\";\r\nimport ProfileStatusWithHooks from \"./ProfileStatusWithHooks\";\r\n\r\n//в props приходит Profile\r\nconst ProfileInfo = ({ profile, status, updateStatus }) => {\r\n  // Если profilе нет(!) то он будет true\r\n  if (!profile) {\r\n    return <Preloader />;\r\n  }\r\n\r\n  return (\r\n    <div>\r\n      <div className={s.descriptionBlock}>\r\n        <img src={profile.photos.large} />\r\n        <ProfileStatusWithHooks status={status} updateStatus={updateStatus} />\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ProfileInfo;\r\n","import React from \"react\";\r\nimport s from \"./Post.module.css\";\r\n\r\nconst Post = (props) => {\r\n  return (\r\n    <div className={s.item}>\r\n      <img src=\"https://hiphop4real.com/wp-content/uploads/2018/08/Lil-Xan-1280x720.jpg\" />\r\n      {props.message}\r\n      <div>\r\n        <span>Like</span>\r\n        {props.likesCount}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Post;\r\n","import React from \"react\";\r\nimport s from \"./MyPosts.module.css\";\r\nimport Post from \"./Post/Post\";\r\n\r\nimport { reduxForm, Field } from \"redux-form\";\r\nimport {\r\n  maxLengthCreator,\r\n  required,\r\n} from \"../../../utils/validators/validators\";\r\nimport { Textarea } from \"../../common/FormsControls/FormsControls\";\r\n\r\nconst maxLength10 = maxLengthCreator(10);\r\n\r\nconst AddNewPostForm = (props) => {\r\n  return (\r\n    <form onSubmit={props.handleSubmit}>\r\n      <div>\r\n        <Field\r\n          name=\"newPostText\"\r\n          component={Textarea} //вместо классической textarea отрисовываем Теxtarea наш компонент(метод) должны отрисовывать не как строка а как название функции-ссылка на компонент\r\n          placeholder=\"Post message\"\r\n          validate={[required, maxLength10]} //вызываем thunk из validator\r\n        />\r\n      </div>\r\n      <div>\r\n        <button>Add post</button>\r\n      </div>\r\n    </form>\r\n  );\r\n};\r\n\r\nconst AddNewPostFormRedux = reduxForm({ form: \"ProfileAddNewPostForm\" })(\r\n  AddNewPostForm\r\n);\r\n\r\n//компонента должна получать данные и callbackИ\r\n//если компоненту нужно оптимизировать,чтобы она лишний раз не вызывала render в функц. компонентах нужно исп. React.memo\r\n//memo-hook который принимает одну компоненту а на выходе возвр. другую, в итоге мы возвращаем MyPosts не которая ниже а ту что создал нам hook\r\nconst MyPosts = React.memo((props) => {\r\n  let postsElements = props.posts.map((p) => (\r\n    <Post message={p.message} likesCount={p.likesCount} />\r\n  ));\r\n\r\n  let newPostElement = React.createRef();\r\n  // onAddPost это callback в values сидит newPostText\r\n  let onAddPost = (values) => {\r\n    props.addPost(values.newPostText);\r\n  };\r\n\r\n  return (\r\n    <div className={s.postsBlock}>\r\n      <h3>My posts</h3>\r\n      <AddNewPostFormRedux onSubmit={onAddPost} />\r\n      <div className={s.posts}>{postsElements}</div>\r\n      {/*когда в форме будет Submit-соберет для нас данные, форма вызовет callback который мы ей передадим */}\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default MyPosts;\r\n\r\n//если не понимаешь то включи 44 ролик с 25 минуты\r\n\r\n//   !!! каждый шаг см. комменты и в тетради стр 24-25 !!!\r\n","import React from \"react\";\r\nimport { addPostCreator } from \"../../../Redux/Profile-reducer\";\r\nimport MyPosts from \"./MyPosts\";\r\nimport { connect } from \"react-redux\";\r\n\r\n// когда происходят любые изменения в state запускается эта функция\r\n// и формир. новый объект и сравн. внутренности этих объектов\r\nconst mapStateToProps = (state) => {\r\n  return {\r\n    posts: state.profilePage.posts, //posts в statE изменился и произошла перерисовка. В pofile-reducer\r\n    newPostText: state.profilePage.newPostText,\r\n  };\r\n};\r\n\r\nconst mapDispatchToProps = (dispatch) => {\r\n  return {\r\n    // newPostText - значение передаем в myPost\r\n    addPost: (newPostText) => {\r\n      dispatch(addPostCreator(newPostText));\r\n    },\r\n  };\r\n};\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(MyPosts);\r\n\r\n//инфу o store вынесли в контейнерную компоненту\r\n//Весь смысл контейнерной компоненты просто быть оберткой и снабдить данными презентационную компоненту. ту MyPosts.jsx,\r\n// для обычной-функциональной компоненты в нашем случае MyPosts.jsx\r\n//           давая нам возможеность не вызывать subscribe. Про connect см коммент. в DalogsCont..\r\n\r\n//   !!! каждый шаг см. комменты и в тетради стр 20-23 в DialogsContainer!!!\r\n","import React from \"react\";\r\nimport ProfileInfo from \"./ProfileInfo/ProfileInfo\";\r\nimport MyPostsContainer from \"./MyPosts/MyPostsContainer\";\r\n\r\nconst Profile = (props) => {\r\n  return (\r\n    <div>\r\n      <ProfileInfo\r\n        profile={props.profile}\r\n        status={props.status} //без this. потому-что мы в функционал компоненте\r\n        updateStatus={props.updateStatus}\r\n      />\r\n      <MyPostsContainer />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Profile;\r\n","import React from \"react\";\r\nimport Profile from \"./Profile\";\r\nimport { connect } from \"react-redux\";\r\nimport {\r\n  getUsersProfile,\r\n  getStatus,\r\n  updateStatus,\r\n} from \"../../Redux/Profile-reducer\";\r\nimport { withRouter } from \"react-router-dom\";\r\nimport { compose } from \"redux\";\r\n\r\n// Чтобы React понимал и взвимодействовал с этим классом как с производителем компонент необходимо (extends)\r\nclass ProfileContainer extends React.Component {\r\n  componentDidMount() {\r\n    let userId = this.props.match.params.userId;\r\n    if (!userId) {\r\n      userId = this.props.authorizedUserId; //11007 //11582\r\n      if (!userId) {\r\n        //если userId нет то тогда Redirect на логин\r\n        this.props.history.push(\"/login\"); //Redirect создавали с помошью компоненты здесь не можем сделать,поэтому делаем так: В пропсах есть объект history и у него есть метод push который можно вызвать и в history можем pushИТЬ новый path(путь) и у нас перейдет переход на новую страницу\r\n      }\r\n    }\r\n    this.props.getUsersProfile(userId);\r\n    this.props.getStatus(userId); //запрос на статус\r\n  }\r\n\r\n  render() {\r\n    // берем props,раскрываем(...) и раскидываем как атрибуты для профиля\r\n    // (Profile компонента)-презентационная получает объект Profile в props\r\n    return (\r\n      <Profile\r\n        {...this.props}\r\n        profile={this.props.profile}\r\n        status={this.props.status}\r\n        updateStatus={this.props.updateStatus}\r\n      />\r\n    );\r\n  }\r\n}\r\n\r\n//основной connect. Берет только данные из профиля\r\nlet mapStateToProps = (state) => ({\r\n  profile: state.profilePage.profile,\r\n  status: state.profilePage.status,\r\n  authorizedUserId: state.auth.userId,\r\n  isAuth: state.auth.isAuth,\r\n});\r\n\r\n//===============================HOC=======================================================================\r\n\r\n//см. комменты в DialogsContainer!!!\r\nexport default compose(\r\n  connect(mapStateToProps, { getUsersProfile, getStatus, updateStatus }),\r\n  withRouter\r\n  // withAuthRedirect\r\n)(ProfileContainer);\r\n//===============================HOC=======================================================================\r\n\r\n// создаем еще одну контейнерную компоненту (mapStateToProps) с помощью Функции connect\r\n//   !!! каждый шаг см. комменты в DialogsContainer!!!\r\n// про HOC и его логику дополнительно см. в withAuthRedirect\r\n"],"sourceRoot":""}